// Spedito ASM Generatior Module
//
// Copyright 2005-2009 Marcello Zaniboni
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 2, with the following exceptions:
//  1) this software can be distributed within any official z88dk package,
//     source archive or installer, without affecting z88dk license terms;
//  2) when the software is distributed with z88dk, the whole source code
//     (and optionally the compiled binaries) for SpEdito, ASM Generator
//     Module and Small Preview Module must be included.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <malloc.h>

#if defined(__WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
#include <windows.h>
#endif

#define APPLICATION_FULL_NAME "Spedito ASM Generatior Module - v. 1.0"

#define MAX_X_RES 640
#define MAX_Y_RES 480
#define PIXEL_OFF '0'
#define PIXEL_ON  '1'

#define ASN_LINE_BEGIN "  defb "

char *spritemap[MAX_Y_RES];
int xres = 0;
int yres = 0;

void errorsleep() {
    #if defined(__WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
        Sleep(8000);
    #else
        sleep(5);
    #endif
}

void exitsleep() {
    #if defined(__WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
        Sleep(2000);
    #else
        sleep(1);
    #endif
}

int init(char *filename) {
    int c, i;
    // init memory
    for (c = 0; c < MAX_Y_RES; c++) {
        spritemap[c] = (char *) malloc((MAX_X_RES + 1) * sizeof(char));
        spritemap[c][0] = '\0';
    }
    // read data
    FILE *datafile;
    char line[MAX_X_RES * 2 + 1];
    if (!(datafile = fopen(filename, "r"))) return 1;
    c = 0;
    while (fgets(line, MAX_X_RES * 2, datafile) && c < MAX_Y_RES + 2) {
        for (i = 0; i < strlen(line); i++) if (line[i] == '\n' || line[i] == '\r') line[i] = '\0';
        if (c == 0) {
            // read x resolution
            xres = atoi(line);
            if (xres < 3 || xres > MAX_X_RES) return 1;
        } else if (c == 1) {
            // read x resolution
            yres = atoi(line);
            if (yres < 3 || yres > MAX_Y_RES) return 1;
        } else {
            // read one sprite row
            if (strlen(line) != xres) {
                fprintf(stderr, "file row %d, invalid length: %d\n", c, strlen(line));
                return 1;
            }
            for (i = 0; i < strlen(line); i++)
                if (line[i] != PIXEL_ON && line[i] != PIXEL_OFF) {
                    fprintf(stderr, "file row %d, column %d, invalid character\n", c + 1, i + 1);
                    return 1;
                }
            strncpy(spritemap[c - 2], line, MAX_X_RES);
        }
        c++;
    }
    fclose(datafile);
    remove(filename);
    return 0;
}

int generatecode(char *fname) {
    int error = 0;
    FILE *outfile;
    if (outfile = fopen(fname, "w")) {
        int bytesperrow, bitfill, i, b, y;
        char byte[9];
        bitfill = xres % 8;
        bytesperrow = xres / 8;
        if (bitfill) bytesperrow++;
        byte[8] = '\0';
        fprintf(outfile, "; Generated by %s\n", APPLICATION_FULL_NAME);
        fprintf(outfile, "; sprite resolution: %d x %d\n", xres, yres);
        fprintf(outfile, ";\n");
        for (y = 0; y < yres; y++) {
            // fill every copy of the strings with empty bits
            char filledrow[MAX_Y_RES + 9];
            char onefillbit[2];
            fprintf(outfile, ASN_LINE_BEGIN);
            onefillbit[0] = PIXEL_OFF; onefillbit[1] = '\0';
            filledrow[0] = '\0';
            strcpy(filledrow, spritemap[y]);
            for (i = 0; i < bitfill; i++) strcat(filledrow, onefillbit);
            // for each byte
            for (b = 0; b < bytesperrow; b++) {
                int n = 0, p = 1;
                // extract the byte
                for (i = 0; i < 8; i++) byte[i] = filledrow[i + b * 8];
                // convert it to a numeric
                for (i = 7; i >= 0; i--, p *= 2) n += (byte[i] == PIXEL_ON) ? 1 * p : 0;
                fprintf(outfile, "$%02x", n);
                if (b != (bytesperrow - 1)) fprintf(outfile, ",");
            }
            fprintf(outfile, "\n");
        }
        fprintf(outfile, "\n");
        fclose(outfile);
    } else {
        fprintf(stderr, "Error saving to file\n%s", fname);
        error = 1;
    }
    return error;
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        char *errormessage =
            APPLICATION_FULL_NAME
            "\n\tthe module is not correctly configured: please"
            "\n\tprovide two parameters: the data file name and"
            "\n\tthe output file name.\n";
        fprintf(stderr, errormessage);
        errorsleep();
        exit(EXIT_FAILURE);
    }
    if (init(argv[1])) {
        char *errormessage =
            APPLICATION_FULL_NAME
            "\n\tthis module cannot open the data file or"
            "\n\tthe file has a wrong format.\n";
        fprintf(stderr, errormessage);
        errorsleep();
        exit(EXIT_FAILURE);
    }
    if(generatecode(argv[2])) {
        char *errormessage =
            APPLICATION_FULL_NAME
            "\n\tERROR while writing output file.\n";
        fprintf(stderr, errormessage);
        errorsleep();
        exit(EXIT_FAILURE);
    }

    printf("%s\n", APPLICATION_FULL_NAME);
    printf("\t...done. Output file: \"%s\"\n", argv[2]);
    exitsleep();
    return EXIT_SUCCESS;
}
